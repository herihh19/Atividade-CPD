1. Implementar os algoritmos Quick Sort e o ShellSort:

Quick Sort:

def quickSort(alist):
   quickSortHelper(alist,0,len(alist)-1)

def quickSortHelper(alist,first,last):
   if first<last:

       splitpoint = partition(alist,first,last)

       quickSortHelper(alist,first,splitpoint-1)
       quickSortHelper(alist,splitpoint+1,last)


def partition(alist,first,last):
   pivotvalue = alist[first]

   leftmark = first+1
   rightmark = last

   done = False
   while not done:

       while leftmark <= rightmark and alist[leftmark] <= pivotvalue:
           leftmark = leftmark + 1

       while alist[rightmark] >= pivotvalue and rightmark >= leftmark:
           rightmark = rightmark -1

       if rightmark < leftmark:
           done = True
       else:
           temp = alist[leftmark]
           alist[leftmark] = alist[rightmark]
           alist[rightmark] = temp

   temp = alist[first]
   alist[first] = alist[rightmark]
   alist[rightmark] = temp


   return rightmark

alist = [54,26,93,17,77,31,44,55,20]
quickSort(alist)
print(alist)

ShellSort:


def shellSort(alist):
    sublistcount = len(alist)//2
    while sublistcount > 0:

      for startposition in range(sublistcount):
        gapInsertionSort(alist,startposition,sublistcount)

      print("After increments of size",sublistcount,
                                   "The list is",alist)

      sublistcount = sublistcount // 2

def gapInsertionSort(alist,start,gap):
    for i in range(start+gap,len(alist),gap):

        currentvalue = alist[i]
        position = i

        while position>=gap and alist[position-gap]>currentvalue:
            alist[position]=alist[position-gap]
            position = position-gap

        alist[position]=currentvalue

alist = [54,26,93,17,77,31,44,55,20]
shellSort(alist)
print(alist)


2. Fazer um programa que contabilize os tempos de cada algoritmos (Insertion, Selection,Bubble, Merge, QuickSort e ShellSort) para ordenar cada um dos tipos de vetores/listas,
conforme listado abaixo:

a. Lista já ordenada
b. Lista ordenada de maneira inversa
c. Lista com dados repetidos
d. Lista com dados aleatórios


3. Pesquisar e implementar o algoritmo Heapsort

O Heapsort é um tipo de árvore binária, onde pode ter até 2 filhos por nó, um filho na esquerda e outro na direita, é uma árvore binária completa
onde sempre estará completa em todos os níveis exceto talvez no último nível.

public static void heapSort(int a[]){
  for(int k = a.length/2-1; k >= 0; k--){
    maxHeapfy(a, k, a.length);
  }
  for(int n = a.length-1; n>=1; n--){
    int temp = a[0];
    a[0] = a[n];
    a[n] = temp;
    maxHeapfy(a, 0, n);// torna o array uma árvore heap

  }
}

4. O shellsort é uma ótima opção para arquivos de tamanho moderado e sua
implementação é simples e requer uma quantidade de código pequena.

a)(X) Verdadeira 
b)( ) Falsa


5. (   ) No Quicksort, a pior escolha para pivô é:*
a) (   ) O extremo de uma lista já ordenada
b) (   ) O elemento inicial da lista não ordenada
c) ( X ) O menor elemento da lista não ordenada
d) (   ) O elemento que esteja no "meio" da lista já ordenada

Justifique sua resposta: Pois quando o pivô é o menor do conjunto não existe divisão dos dados.

6. O algoritmo Insertion Sort possui comportamento melhor do que o método da bolha(Bubblesort). Esta afirmação é:
a)( X ) Verdadeira
b)(   )Falsa

Justifique sua resposta: o Insertion Sort não é necessário que sempre haja comparações até o fim.


7. O pivô recomendado para método quicksort é:

A)() O primeiro elemento
B)() O último elemento
C)(X) O elemento central
D)() Qualquer elemento


8. Suponha que você tenha a seguinte lista para realizar ordenação: [19, 1, 9, 7, 3, 10, 13,15, 8, 12]. 
Qual opção representa a lista parcialmente ordenada após três passos completos de bubblesort?

a) (   )  [1, 9, 19, 7, 3, 10, 13, 15, 8, 12]
b) (   )  [1, 3, 7, 9, 10, 8, 12, 13, 15, 19]
c) (   )  [1, 7, 3, 9, 10, 13, 8, 12, 15, 19]
d) (   )  [1, 9, 19, 7, 3, 10, 13, 15, 8, 12]
e) ( X )  [1, 3, 7, 9, 8, 10, 12, 13, 15, 19]
Nenhuma das alternativas
Justifique sua resposta: Pois no método bubblesort ele "flutua" na lista buscando a ordenação dos números, então como começa com o n° 19 ele vai ir passando pela lista 
e trocando com os todos os n° menores que ele até o final da lista, esse seria o primeiro passo, depois novamente no início da lista irá pegar o n° maior que estiver
antes de um n° menor e irá fazer as trocas necessárias até o fim, depois ele fará novamente a revisão trocando os números que ainda não estão ordenados, finalizando assim 
3 passos completos. 

